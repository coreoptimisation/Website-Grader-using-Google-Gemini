Short answer: yes — you don’t need two code paths. Make the runtime identical in dev and prod so the browser is always found the same way. Here are three solid options (pick one and you can delete all the dev/prod branching):

# 1) Let Playwright manage the browser everywhere (simplest)

* Pin Playwright and its bundled Chromium; never hard-code an executable path.
* Install the browser at build time:

```bash
# package.json scripts
"postinstall": "npx playwright install --with-deps chromium"
```

* Launch without `executablePath`:

```ts
import { chromium } from 'playwright';

export async function launchBrowser() {
  // Optional: prefer a remote browser when provided
  if (process.env.BROWSER_WS_ENDPOINT) {
    return chromium.connectOverCDP(process.env.BROWSER_WS_ENDPOINT);
  }

  return chromium.launch({
    headless: true,
    channel: 'chromium',          // use Playwright’s bundled Chromium
    args: ['--no-sandbox', '--disable-dev-shm-usage']
  });
}
```

* Ensure consistent install location:

  * Default is fine, but you can set `PLAYWRIGHT_BROWSERS_PATH=.cache/ms-playwright` in both envs to be explicit.
* This removes all Nix paths and works on Replit, Docker, VM, etc., as long as the postinstall runs.

# 2) Containerise the scanner (most robust + reproducible)

Run the scanner as a separate worker service built on the official Playwright image, so dev and prod are bit-for-bit consistent.

**Dockerfile**

```dockerfile
FROM mcr.microsoft.com/playwright:v1.47.0-jammy
WORKDIR /app
COPY package*.json ./
RUN npm ci && npx playwright install --with-deps chromium
COPY . .
CMD ["npm","run","start:scanner"]
```

**docker-compose.yml (example)**

```yaml
services:
  scanner:
    build: .
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - QUEUE_URL=${QUEUE_URL}
    shm_size: 1gb
```

Pattern:

* Web app enqueues a scan job → scanner container runs Playwright → writes to DB → optional webhook back to app.
* No special paths, no branching, same image locally and in prod.

# 3) Use a remote headless browser as a fallback (scales well)

Keep your code path identical and add an optional **remote** browser override via `BROWSER_WS_ENDPOINT` (e.g., Browserless / self-hosted Chrome):

```ts
const ws = process.env.BROWSER_WS_ENDPOINT;
if (ws) return chromium.connectOverCDP(ws);
```

If the env var isn’t set, it just uses the bundled Chromium. This gives you a zero-code-change escape hatch if the host environment is locked down.

---

## Guardrails you should add either way

**A) One launcher, many callers**
Centralise launch logic in a small module (like above) and import it everywhere (accessibility, performance, crawler, screenshots). This prevents drift.

**B) Never surface “0” for “everything failed”**
Tweak your aggregation so “all pages error” returns a failed scan status with a reason, not zeros:

```ts
const allFailed = results.length > 0 && results.every(r => r.error);
if (allFailed) {
  return {
    status: 'FAILED',
    reason: results.find(r => r.error)?.errorMessage ?? 'Unknown browser failure',
    failedPages: results.length
  };
}
```

**C) Health check at startup**
Run a tiny one-shot launch/close during boot (or a `/health` endpoint) to fail fast if the browser isn’t available.

**D) CI/CD step**
Make sure `npx playwright install --with-deps chromium` runs in your deploy/build phase so prod always has the exact browser you expect.

---

## Recommendation

If you want the quickest win with the fewest moving parts, go with **Option 1** and delete all dev/prod branching. If you also want perfect reproducibility and easier scaling, step up to **Option 2** (containerised scanner worker). Option 3 is a nice safety net you can keep in the same code path via one env var.

Happy to sketch the minimal PR (launcher module + aggregator fix + script changes) if you want me to drop it into your repo.
